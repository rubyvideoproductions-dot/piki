<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>peak. | Video Production Studio</title>
  <link rel="icon" href="assets/logo.png" type="image/png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/style.css">
  <link rel="stylesheet" href="css/scroll-effect.css">
</head>
<body class="loading">

  <!-- LOADER SECTION -->
  <div id="loader" class="loader-container">
      <div class="loader-content">
        <img src="assets/logo.svg" alt="peak." class="loader-logo">
      </div>
  </div>
  <!-- END LOADER SECTION -->

  <!-- MAIN CONTENT -->
  <header class="header">
    <nav class="nav">
      <div class="nav-left">
        <a href="works.html" class="nav-link">works</a>
      </div>
      <a href="index.html" class="logo">
        <span class="logo-text">peak.</span>
      </a>
      <div class="nav-right">
        <a href="contact.html" class="nav-link">contact</a>
      </div>
    </nav>
  </header>

  <div class="main-content" id="mainContent">

    <!-- Typographic Cover -->
    <section id="hero-cover">
        <!-- Center Stage -->
        <div class="cover-center">
            <h1 class="main-title reveal-text">YOUR GOALS. OUR SPARK.<br>PEAK RESULTS.</h1>
        </div>
        <a href="#showreel" class="scroll-down transition-fade"></a>
    </section>

    <!-- Showreel -->
    <section id="showreel" class="section" style="padding-left: 0; padding-right: 0;">
      <div class="video-container" id="videoCard" style="width: 85%; border-radius: 24px; opacity: 1.0; transform: translateY(0);">
        <span class="glow"></span>
        <div class="video-wrapper">
           <iframe src="https://player.vimeo.com/video/1152345652?autoplay=1&loop=1&muted=1&background=1" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>
        </div>
      </div>
    </section>

    <header class="scroll-header">
      <h1 class="fluid">we can<br />create.</h1>
    </header>
    <main class="scroll-container">
      <section class="content-section fluid">
        <h2><span aria-hidden="true">we can&nbsp;</span>
          <span class="sr-only">we can build things.</span>
        </h2>
        <ul class="scroll-list" aria-hidden="true" style="--count: 10">
          <li style="--i: 0">motion design.</li>
          <li style="--i: 1">3d animation.</li>
          <li style="--i: 2">music videos.</li>
          <li style="--i: 3">broadcast.</li>
          <li style="--i: 4">commercials.</li>
          <li style="--i: 5">tech reels.</li>
          <li style="--i: 6">drones.</li>
          <li style="--i: 7">storytelling.</li>
          <li style="--i: 8">production.</li>
          <li style="--i: 9">excellence.</li>
        </ul>
      </section>
      <section class="content-section">
        <h2 class="fluid">peak.</h2>
      </section>
    </main>
    <footer class="scroll-footer">© 2026 peak.</footer>
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- GSAP & ScrollTrigger -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
  <script>
    // TouchTexture class
    class TouchTexture {
      constructor() {
        this.size = 64;
        this.width = this.height = this.size;
        this.maxAge = 64;
        this.radius = 0.1 * this.size;
        this.speed = 1 / this.maxAge;
        this.trail = [];
        this.last = null;
        this.initTexture();
      }
      initTexture() {
        this.canvas = document.createElement("canvas");
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.ctx = this.canvas.getContext("2d");
        this.ctx.fillStyle = "black";
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.texture = new THREE.Texture(this.canvas);
      }
      update() {
        this.clear();
        let speed = this.speed;
        for (let i = this.trail.length - 1; i >= 0; i--) {
          const point = this.trail[i];
          let f = point.force * speed * (1 - point.age / this.maxAge);
          point.x += point.vx * f;
          point.y += point.vy * f;
          point.age++;
          if (point.age > this.maxAge) {
            this.trail.splice(i, 1);
          } else {
            this.drawPoint(point);
          }
        }
        this.texture.needsUpdate = true;
      }
      clear() {
        this.ctx.fillStyle = "black";
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      }
      addTouch(point) {
        let force = 0, vx = 0, vy = 0;
        const last = this.last;
        if (last) {
          const dx = point.x - last.x;
          const dy = point.y - last.y;
          if (dx === 0 && dy === 0) return;
          const dd = dx * dx + dy * dy;
          let d = Math.sqrt(dd);
          vx = dx / d;
          vy = dy / d;
          force = Math.min(dd * 5000, 1.0);
        }
        this.last = { x: point.x, y: point.y };
        this.trail.push({ x: point.x, y: point.y, age: 0, force, vx, vy });
      }
      drawPoint(point) {
        const pos = { x: point.x * this.width, y: (1 - point.y) * this.height };
        let intensity = 1;
        if (point.age < this.maxAge * 0.3) {
          intensity = Math.sin((point.age / (this.maxAge * 0.3)) * (Math.PI / 2));
        } else {
          const t = 1 - (point.age - this.maxAge * 0.3) / (this.maxAge * 0.7);
          intensity = -t * (t - 2);
        }
        intensity *= point.force;
        const radius = this.radius;
        let color = `${((point.vx + 1) / 2) * 255}, ${((point.vy + 1) / 2) * 255}, ${intensity * 255}`;
        let offset = this.size * 5;
        this.ctx.shadowOffsetX = offset;
        this.ctx.shadowOffsetY = offset;
        this.ctx.shadowBlur = radius * 1;
        this.ctx.shadowColor = `rgba(${color},${0.2 * intensity})`;
        this.ctx.beginPath();
        this.ctx.fillStyle = "rgba(255,0,0,1)";
        this.ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }

    // GradientBackground class - Light Pastel
    class GradientBackground {
      constructor(sceneManager) {
        this.sceneManager = sceneManager;
        this.mesh = null;
        this.uniforms = {
          uTime: { value: 0 },
          uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          // Dark/Deep Purple/Burgundy Palette
          uColor1: { value: new THREE.Color('#4a0e2e') }, // Deep Burgundy
          uColor2: { value: new THREE.Color('#2e003e') }, // Deep Purple
          uColor3: { value: new THREE.Color('#1a0b2e') }, // Dark Violet
          uColor4: { value: new THREE.Color('#3d001d') }, // Deep Burgundy Variant
          uColor5: { value: new THREE.Color('#190028') }, // Very Dark Purple
          uColor6: { value: new THREE.Color('#000000') }, // Black
          uSpeed: { value: 0.2 },
          uIntensity: { value: 1.4 },
          uTouchTexture: { value: null },
          uGrainIntensity: { value: 0.03 },
          uBaseColor: { value: new THREE.Color('#121212') }, // Dark Gray Base
        };
      }
      init() {
        const viewSize = this.sceneManager.getViewSize();
        const geometry = new THREE.PlaneGeometry(viewSize.width, viewSize.height, 1, 1);
        const material = new THREE.ShaderMaterial({
          uniforms: this.uniforms,
          vertexShader: `
            varying vec2 vUv;
            void main() {
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
              vUv = uv;
            }
          `,
          fragmentShader: `
            uniform float uTime;
            uniform vec2 uResolution;
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            uniform vec3 uColor3;
            uniform vec3 uColor4;
            uniform vec3 uColor5;
            uniform vec3 uColor6;
            uniform float uSpeed;
            uniform float uIntensity;
            uniform sampler2D uTouchTexture;
            uniform float uGrainIntensity;
            uniform vec3 uBaseColor;
            varying vec2 vUv;
            
            float grain(vec2 uv, float time) {
              vec2 grainUv = uv * uResolution * 0.5;
              return fract(sin(dot(grainUv + time, vec2(12.9898, 78.233))) * 43758.5453) * 2.0 - 1.0;
            }
            
            vec3 getGradientColor(vec2 uv, float time) {
              float gradientRadius = 0.5;
              
              vec2 center1 = vec2(0.5 + sin(time * uSpeed * 0.4) * 0.4, 0.5 + cos(time * uSpeed * 0.5) * 0.4);
              vec2 center2 = vec2(0.5 + cos(time * uSpeed * 0.6) * 0.5, 0.5 + sin(time * uSpeed * 0.45) * 0.5);
              vec2 center3 = vec2(0.5 + sin(time * uSpeed * 0.35) * 0.45, 0.5 + cos(time * uSpeed * 0.55) * 0.45);
              vec2 center4 = vec2(0.5 + cos(time * uSpeed * 0.5) * 0.4, 0.5 + sin(time * uSpeed * 0.4) * 0.4);
              vec2 center5 = vec2(0.5 + sin(time * uSpeed * 0.7) * 0.35, 0.5 + cos(time * uSpeed * 0.6) * 0.35);
              vec2 center6 = vec2(0.5 + cos(time * uSpeed * 0.45) * 0.5, 0.5 + sin(time * uSpeed * 0.65) * 0.5);
              
              float dist1 = length(uv - center1);
              float dist2 = length(uv - center2);
              float dist3 = length(uv - center3);
              float dist4 = length(uv - center4);
              float dist5 = length(uv - center5);
              float dist6 = length(uv - center6);
              
              float influence1 = 1.0 - smoothstep(0.0, gradientRadius, dist1);
              float influence2 = 1.0 - smoothstep(0.0, gradientRadius, dist2);
              float influence3 = 1.0 - smoothstep(0.0, gradientRadius, dist3);
              float influence4 = 1.0 - smoothstep(0.0, gradientRadius, dist4);
              float influence5 = 1.0 - smoothstep(0.0, gradientRadius, dist5);
              float influence6 = 1.0 - smoothstep(0.0, gradientRadius, dist6);
              
              vec3 color = uBaseColor;
              color = mix(color, uColor1, influence1 * 0.5 * (0.6 + 0.4 * sin(time * uSpeed)));
              color = mix(color, uColor2, influence2 * 0.45 * (0.6 + 0.4 * cos(time * uSpeed * 1.2)));
              color = mix(color, uColor3, influence3 * 0.5 * (0.6 + 0.4 * sin(time * uSpeed * 0.8)));
              color = mix(color, uColor4, influence4 * 0.4 * (0.6 + 0.4 * cos(time * uSpeed * 1.3)));
              color = mix(color, uColor5, influence5 * 0.45 * (0.6 + 0.4 * sin(time * uSpeed * 1.1)));
              color = mix(color, uColor6, influence6 * 0.4 * (0.6 + 0.4 * cos(time * uSpeed * 0.9)));
              
              return clamp(color, vec3(0.0), vec3(1.0));
            }
            
            void main() {
              vec2 uv = vUv;
              vec4 touchTex = texture2D(uTouchTexture, uv);
              float vx = -(touchTex.r * 2.0 - 1.0);
              float vy = -(touchTex.g * 2.0 - 1.0);
              float intensity = touchTex.b;
              uv.x += vx * 0.1 * intensity;
              uv.y += vy * 0.1 * intensity;
              
              vec3 color = getGradientColor(uv, uTime);
              color += grain(uv, uTime) * uGrainIntensity;
              color = clamp(color, vec3(0.0), vec3(1.0));
              
              gl_FragColor = vec4(color, 1.0);
            }
          `
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.sceneManager.scene.add(this.mesh);
      }
      update(delta) {
        if (this.uniforms.uTime) this.uniforms.uTime.value += delta;
      }
      onResize(width, height) {
        const viewSize = this.sceneManager.getViewSize();
        if (this.mesh) {
          this.mesh.geometry.dispose();
          this.mesh.geometry = new THREE.PlaneGeometry(viewSize.width, viewSize.height, 1, 1);
        }
        if (this.uniforms.uResolution) this.uniforms.uResolution.value.set(width, height);
      }
    }

    // App class
    class App {
      constructor() {
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(this.renderer.domElement);
        this.renderer.domElement.id = "webGLApp";

        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
        this.camera.position.z = 50;
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0xf5f3ff);
        this.clock = new THREE.Clock();

        this.touchTexture = new TouchTexture();
        this.gradientBackground = new GradientBackground(this);
        this.gradientBackground.uniforms.uTouchTexture.value = this.touchTexture.texture;
        this.init();
      }
      init() {
        this.gradientBackground.init();
        this.tick();
        window.addEventListener("resize", () => this.onResize());
        window.addEventListener("mousemove", (ev) => this.onMouseMove(ev));
        window.addEventListener("touchmove", (ev) => this.onTouchMove(ev));
      }
      onTouchMove(ev) {
        const touch = ev.touches[0];
        this.onMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
      }
      onMouseMove(ev) {
        this.mouse = { x: ev.clientX / window.innerWidth, y: 1 - ev.clientY / window.innerHeight };
        this.touchTexture.addTouch(this.mouse);
      }
      getViewSize() {
        const fovInRadians = (this.camera.fov * Math.PI) / 180;
        const height = Math.abs(this.camera.position.z * Math.tan(fovInRadians / 2) * 2);
        return { width: height * this.camera.aspect, height };
      }
      update(delta) {
        this.touchTexture.update();
        this.gradientBackground.update(delta);
      }
      render() {
        const delta = Math.min(this.clock.getDelta(), 0.1);
        this.renderer.render(this.scene, this.camera);
        this.update(delta);
      }
      tick() {
        this.render();
        requestAnimationFrame(() => this.tick());
      }
      onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.gradientBackground.onResize(window.innerWidth, window.innerHeight);
      }
    }

    // Initialize
    const app = new App();

    // Glowing card effect
    const glowingElements = [
        document.getElementById('videoCard'),
        ...document.querySelectorAll('.glowing-card')
    ].filter(Boolean);
    
    const centerOfElement = ($el) => {
      const { width, height } = $el.getBoundingClientRect();
      return [width/2, height/2];
    };
    
    const pointerPositionRelativeToElement = ($el, e) => {
      const { left, top, width, height } = $el.getBoundingClientRect();
      const x = e.clientX - left;
      const y = e.clientY - top;
      const px = Math.min(Math.max((100 / width) * x, 0), 100);
      const py = Math.min(Math.max((100 / height) * y, 0), 100);
      return { pixels: [x,y], percent: [px,py] };
    };
    
    const angleFromPointerEvent = (dx, dy) => {
      if (dx === 0 && dy === 0) return 0;
      let angleRadians = Math.atan2(dy, dx);
      let angleDegrees = angleRadians * (180 / Math.PI) + 90;
      if (angleDegrees < 0) angleDegrees += 360;
      return angleDegrees;
    };
    
    const distanceFromCenter = ($el, x, y) => {
      const [cx,cy] = centerOfElement($el);
      return [x - cx, y - cy];
    };
    
    const closenessToEdge = ($el, x, y) => {
      const [cx,cy] = centerOfElement($el);
      const [dx,dy] = distanceFromCenter($el, x, y);
      let k_x = dx !== 0 ? cx / Math.abs(dx) : Infinity;
      let k_y = dy !== 0 ? cy / Math.abs(dy) : Infinity;
      return Math.min(Math.max(1 / Math.min(k_x, k_y), 0), 1);
    };
    
    const cardUpdate = (e) => {
      const $el = e.currentTarget;
      const position = pointerPositionRelativeToElement($el, e);
      const [px,py] = position.pixels;
      const [dx,dy] = distanceFromCenter($el, px, py);
      const edge = closenessToEdge($el, px, py);
      const angle = angleFromPointerEvent(dx, dy);
      
      $el.style.setProperty('--pointer-°', `${angle.toFixed(3)}deg`);
      $el.style.setProperty('--pointer-d', `${(edge * 100).toFixed(3)}`);
      $el.classList.remove('animating');
    };
    
    glowingElements.forEach($el => {
        $el.addEventListener('pointermove', cardUpdate);
    });

    // Loader logic
    const loader = document.getElementById('loader');
    const mainContent = document.getElementById('mainContent');
    const loaderStartTime = Date.now();

    window.addEventListener('load', () => {
        const diff = Date.now() - loaderStartTime;
        const delay = Math.max(0, 3000 - diff);
        
        setTimeout(() => {
            hideLoader();
        }, delay);
    });

    function hideLoader() {
      if (loader) {
        loader.classList.add('hidden');
        // Add a scale-up effect to the logo as it fades out for a more dynamic feel
        const logo = loader.querySelector('.loader-logo');
        if (logo) {
          logo.style.transition = 'transform 1.2s cubic-bezier(0.4, 0, 0.2, 1), opacity 1.2s cubic-bezier(0.4, 0, 0.2, 1)';
          logo.style.transform = 'scale(1.1)';
          logo.style.opacity = '0';
        }
      }
      document.body.classList.remove('loading');
      if (mainContent) mainContent.classList.add('visible');
      
      // Trigger hero animations
      setTimeout(() => {
          document.querySelectorAll('#hero-cover .reveal-text').forEach((el, index) => {
              setTimeout(() => el.classList.add('visible'), index * 200);
          });
      }, 500);
    }

    // Scroll Animation (Intersection Observer)
    const observerOptions = {
      root: null,
      rootMargin: '0px',
      threshold: 0.1
    };

    const observer = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
        }
      });
    }, observerOptions);

    document.querySelectorAll('.section .reveal-text').forEach(el => {
      observer.observe(el);
    });

    // Cinematic Transition for Video Card
    function updateCinematicTransition() {
      const videoCard = document.getElementById('videoCard');
      if (!videoCard) return;
      
      const rect = videoCard.parentElement.getBoundingClientRect();
      const windowHeight = window.innerHeight;
      
      // Calculate progress: 0 when top of section is at bottom of viewport, 
      // 1 when top of section reaches top of viewport
      const progress = Math.min(Math.max((windowHeight - rect.top) / windowHeight, 0), 1);
      
      // Opacity: 0.9 to 1
      const opacity = 0.9 + (progress * 0.1);
      
      // Double the expansion speed: reach 100% at scrollProgress = 0.6
      // Start expansion from the initial 30% visibility point (progress = 0.3)
      const expansionProgress = Math.min(Math.max((progress - 0.3) / (0.6 - 0.3), 0), 1);
      
      // Width: 85vw to 100vw
      const width = 85 + (expansionProgress * 15);
      
      // Border Radius: 24px to 0px
      const borderRadius = 24 * (1 - expansionProgress);
      
      // Parallax: 60px to 0 (reduced to ensure initial visibility)
      const easeProgress = 1 - Math.pow(1 - progress, 3);
      const translateVal = 60 * (1 - easeProgress);
      
      videoCard.style.opacity = opacity;
      videoCard.style.width = `${width}vw`;
      videoCard.style.borderRadius = `${borderRadius}px`;
      videoCard.style.transform = `translateY(${translateVal}px)`;
      
      // Ensure precise alignment and no borders/gaps
      videoCard.style.border = 'none';
      videoCard.style.outline = 'none';
      videoCard.style.position = 'relative';
      videoCard.style.left = '0';
      videoCard.style.right = '0';
      
      // If fully expanded, ensure edge-to-edge with no gaps
      if (expansionProgress >= 1) {
          videoCard.style.width = '100vw';
          videoCard.style.margin = '0';
      } else {
          videoCard.style.margin = '0 auto';
      }
    }

    window.addEventListener('scroll', updateCinematicTransition);
    // Initial call to set state
    updateCinematicTransition();

    // Scroll Down Button Logic
    const scrollDownBtn = document.querySelector('.scroll-down');
    if (scrollDownBtn) {
      scrollDownBtn.addEventListener('click', (e) => {
        e.preventDefault();
        const target = document.querySelector('#showreel');
        if (target) {
          target.scrollIntoView({ behavior: 'smooth' });
        }
      });

      // Fade out on scroll
      window.addEventListener('scroll', () => {
        const scrollPos = window.scrollY;
        if (scrollPos > 100) {
          scrollDownBtn.style.opacity = '0';
          scrollDownBtn.style.pointerEvents = 'none';
        } else {
          scrollDownBtn.style.opacity = '1';
          scrollDownBtn.style.pointerEvents = 'all';
        }
      });
    }

    // --- SCROLL EFFECT LOGIC ---
    gsap.registerPlugin(ScrollTrigger);

    // Set initial state
    document.documentElement.dataset.theme = 'dark';
    document.documentElement.dataset.animate = 'true';
    document.documentElement.dataset.snap = 'true';

    const scrollHeader = document.querySelector('.scroll-header');
    const showreel = document.querySelector('#showreel');

    if (scrollHeader && showreel) {
      gsap.fromTo(scrollHeader, 
        { 
          opacity: 0, 
          scale: 0.8, 
          filter: 'blur(15px)',
          y: 100 
        },
        {
          opacity: 1,
          scale: 1,
          filter: 'blur(0px)',
          y: 0,
          scrollTrigger: {
            trigger: showreel,
            start: 'bottom 95%',
            end: 'bottom 40%',
            scrub: 1,
            invalidateOnRefresh: true,
          }
        }
      );

      gsap.to('.scroll-header h1', {
        y: -120,
        ease: 'none',
        scrollTrigger: {
          trigger: scrollHeader,
          start: 'top bottom',
          end: 'bottom top',
          scrub: true,
        }
      });
    }

    // Animate the items in the scroll-list
    const items = gsap.utils.toArray('.scroll-list li');
    if (items.length > 0) {
      gsap.set(items, { opacity: (i) => (i !== 0 ? 0.2 : 1) });

      const dimmer = gsap.timeline()
        .to(items.slice(1), { opacity: 1, stagger: 0.5 })
        .to(items.slice(0, items.length - 1), { opacity: 0.2, stagger: 0.5 }, 0);

      ScrollTrigger.create({
        trigger: items[0],
        endTrigger: items[items.length - 1],
        start: 'center center',
        end: 'center center',
        animation: dimmer,
        scrub: 0.2,
      });

      // Hue transition for the scroll-list
      const scroller = gsap.timeline().fromTo(
        document.documentElement,
        { '--hue': 240 },
        { '--hue': 350, ease: 'none' }
      );

      ScrollTrigger.create({
        trigger: items[0],
        endTrigger: items[items.length - 1],
        start: 'center center',
        end: 'center center',
        animation: scroller,
        scrub: 0.2,
      });

      // Chroma entry/exit
      gsap.fromTo(document.documentElement,
        { '--chroma': 0 },
        {
          '--chroma': 0.3,
          ease: 'none',
          scrollTrigger: {
            scrub: 0.2,
            trigger: items[0],
            start: 'center center+=40',
            end: 'center center',
          }
        }
      );
      gsap.fromTo(document.documentElement,
        { '--chroma': 0.3 },
        {
          '--chroma': 0,
          ease: 'none',
          scrollTrigger: {
            scrub: 0.2,
            trigger: items[items.length - 2],
            start: 'center center',
            end: 'center center-=40',
          }
        }
      );
    }

    window.addEventListener('load', () => {
      setTimeout(() => {
        ScrollTrigger.refresh();
      }, 1000);
    });
  </script>
</body>
</html>