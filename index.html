<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>peak. | Video Production Studio</title>
  <link rel="icon" href="assets/logo.png" type="image/png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/style.css">
</head>
<body class="loading">

  <!-- LOADER SECTION -->
  <div id="loader" class="loader-container">
      <div class="loader-content">
        <h1 class="loader-text">peak.</h1>
        <svg viewBox="0 0 100 60" class="loader-svg">
            <path d="M10 50 L35 30 L50 45 L75 20 L95 50" class="mountain-path" fill="none" stroke="#111" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" pathLength="100"/>
        </svg>
      </div>
  </div>
  <!-- END LOADER SECTION -->

  <!-- MAIN CONTENT -->
  <header class="header">
    <nav class="nav">
      <div class="nav-left">
        <a href="#showreel" class="nav-link">Works</a>
      </div>
      <a href="index.html" class="logo">
        <span class="logo-text">peak.</span>
      </a>
      <div class="nav-right">
        <a href="contact.html" class="nav-link">Contact</a>
      </div>
    </nav>
  </header>

  <div class="main-content" id="mainContent">

    <!-- Typographic Cover -->
    <section id="hero-cover">
        <!-- Center Stage -->
        <div class="cover-center">
            <h1 class="main-title reveal-text">YOUR GOALS. OUR SPARK.<br>PEAK RESULTS.</h1>
            <h2 class="subtitle reveal-text">ADAPTIVE CREATIVE PROFESSIONAL EFFICIENT.</h2>
        </div>
    </section>

    <!-- Showreel -->
    <section id="showreel" class="section">
      <div class="video-container reveal-text" id="videoCard" style="width: 100%; max-width: none;">
        <span class="glow"></span>
        <div class="video-wrapper">
           <iframe src="https://player.vimeo.com/video/1152345652?autoplay=1&loop=1&muted=1&background=1" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>
        </div>
      </div>
    </section>

    <!-- Services Marquee -->
    <section class="marquee-container">
      <div class="marquee">
        <span>DRONES</span><span>MOTION DESIGN</span><span>3D ANIMATION</span><span>MUSIC VIDEOS</span><span>BROADCAST</span><span>TECH SHOWREELS</span><span>STARTUP ADS</span><span>CREATIVE DIRECTION</span>
        <span>DRONES</span><span>MOTION DESIGN</span><span>3D ANIMATION</span><span>MUSIC VIDEOS</span><span>BROADCAST</span><span>TECH SHOWREELS</span><span>STARTUP ADS</span><span>CREATIVE DIRECTION</span>
      </div>
    </section>
    
    <!-- Why Us -->
    <section id="why-us" class="section">
        <div class="container">
            <h2 class="section-title reveal-text">Why Us?</h2>
            <p class="section-text reveal-text">We don't just make videos. We craft visual experiences that resonate with your audience and drive real results.</p>
            
            <div class="why-us-grid">
                <!-- Card 1 -->
                <div class="glowing-card reveal-text">
                    <div class="glow"></div>
                    <div class="card-icon">âš¡</div>
                    <h3 class="card-title">Adaptive</h3>
                    <p class="card-desc">AI-powered workflows that evolve with your project's needs, ensuring maximum efficiency.</p>
                </div>
                
                <!-- Card 2 -->
                <div class="glowing-card reveal-text">
                    <div class="glow"></div>
                    <div class="card-icon">ðŸŽ¨</div>
                    <h3 class="card-title">Creative</h3>
                    <p class="card-desc">Bold visual storytelling that breaks through the noise and captures your brand's essence.</p>
                </div>
                
                <!-- Card 3 -->
                <div class="glowing-card reveal-text">
                    <div class="glow"></div>
                    <div class="card-icon">ðŸ’Ž</div>
                    <h3 class="card-title">Professional</h3>
                    <p class="card-desc">High-end production quality delivered by a team of experts dedicated to excellence.</p>
                </div>
                
                <!-- Card 4 -->
                <div class="glowing-card reveal-text">
                    <div class="glow"></div>
                    <div class="card-icon">ðŸš€</div>
                    <h3 class="card-title">Efficient</h3>
                    <p class="card-desc">Fast turnaround times without compromising on quality, keeping you ahead of the curve.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- About (Who We Are) -->
    <section class="section">
      <div class="grid-2">
        <div>
          <h2 class="section-title reveal-text">Who we are</h2>
          <p class="section-text reveal-text">We are an AI-powered video production studio, crafting advertising and marketing content for brands that want to stand out.</p>
          <p class="section-text reveal-text" style="margin-top: 1.2rem;">Combining cutting-edge technology with creative vision to produce content that drives results.</p>
          <a href="contact.html" class="btn-primary" style="margin-top: 2.5rem;">Get in touch</a>
        </div>
        <div class="placeholder-box reveal-text"><span>[ Photo ]</span></div>
      </div>
    </section>

    <!-- Contact -->
    <section class="contact-section">
      <h2 class="contact-title reveal-text">Let's create together</h2>
      <p class="contact-text reveal-text">Ready to elevate your brand with compelling video content?</p>
      <a href="mailto:hello@peak.studio" class="btn-primary">Start a project</a>
    </section>

    <!-- Footer -->
    <footer class="footer">
      <div class="footer-content">
        <span>Â© 2026 peak.</span>
        <span>Tel Aviv, Israel</span>
      </div>
    </footer>
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // TouchTexture class
    class TouchTexture {
      constructor() {
        this.size = 64;
        this.width = this.height = this.size;
        this.maxAge = 64;
        this.radius = 0.1 * this.size;
        this.speed = 1 / this.maxAge;
        this.trail = [];
        this.last = null;
        this.initTexture();
      }
      initTexture() {
        this.canvas = document.createElement("canvas");
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.ctx = this.canvas.getContext("2d");
        this.ctx.fillStyle = "black";
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.texture = new THREE.Texture(this.canvas);
      }
      update() {
        this.clear();
        let speed = this.speed;
        for (let i = this.trail.length - 1; i >= 0; i--) {
          const point = this.trail[i];
          let f = point.force * speed * (1 - point.age / this.maxAge);
          point.x += point.vx * f;
          point.y += point.vy * f;
          point.age++;
          if (point.age > this.maxAge) {
            this.trail.splice(i, 1);
          } else {
            this.drawPoint(point);
          }
        }
        this.texture.needsUpdate = true;
      }
      clear() {
        this.ctx.fillStyle = "black";
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      }
      addTouch(point) {
        let force = 0, vx = 0, vy = 0;
        const last = this.last;
        if (last) {
          const dx = point.x - last.x;
          const dy = point.y - last.y;
          if (dx === 0 && dy === 0) return;
          const dd = dx * dx + dy * dy;
          let d = Math.sqrt(dd);
          vx = dx / d;
          vy = dy / d;
          force = Math.min(dd * 5000, 1.0);
        }
        this.last = { x: point.x, y: point.y };
        this.trail.push({ x: point.x, y: point.y, age: 0, force, vx, vy });
      }
      drawPoint(point) {
        const pos = { x: point.x * this.width, y: (1 - point.y) * this.height };
        let intensity = 1;
        if (point.age < this.maxAge * 0.3) {
          intensity = Math.sin((point.age / (this.maxAge * 0.3)) * (Math.PI / 2));
        } else {
          const t = 1 - (point.age - this.maxAge * 0.3) / (this.maxAge * 0.7);
          intensity = -t * (t - 2);
        }
        intensity *= point.force;
        const radius = this.radius;
        let color = `${((point.vx + 1) / 2) * 255}, ${((point.vy + 1) / 2) * 255}, ${intensity * 255}`;
        let offset = this.size * 5;
        this.ctx.shadowOffsetX = offset;
        this.ctx.shadowOffsetY = offset;
        this.ctx.shadowBlur = radius * 1;
        this.ctx.shadowColor = `rgba(${color},${0.2 * intensity})`;
        this.ctx.beginPath();
        this.ctx.fillStyle = "rgba(255,0,0,1)";
        this.ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }

    // GradientBackground class - DARK THEME
    class GradientBackground {
      constructor(sceneManager) {
        this.sceneManager = sceneManager;
        this.mesh = null;
        this.uniforms = {
          uTime: { value: 0 },
          uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          // Light Pastel Palette
          uColor1: { value: new THREE.Color('#e0c3fc') },
          uColor2: { value: new THREE.Color('#8ec5fc') },
          uColor3: { value: new THREE.Color('#ffdee9') },
          uColor4: { value: new THREE.Color('#e0c3fc') },
          uColor5: { value: new THREE.Color('#8ec5fc') },
          uColor6: { value: new THREE.Color('#ffdee9') },
          uSpeed: { value: 0.2 },
          uIntensity: { value: 1.4 },
          uTouchTexture: { value: null },
          uGrainIntensity: { value: 0.03 },
          uBaseColor: { value: new THREE.Color('#f5f3ff') },
        };
      }
      init() {
        const viewSize = this.sceneManager.getViewSize();
        const geometry = new THREE.PlaneGeometry(viewSize.width, viewSize.height, 1, 1);
        const material = new THREE.ShaderMaterial({
          uniforms: this.uniforms,
          vertexShader: `
            varying vec2 vUv;
            void main() {
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
              vUv = uv;
            }
          `,
          fragmentShader: `
            uniform float uTime;
            uniform vec2 uResolution;
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            uniform vec3 uColor3;
            uniform vec3 uColor4;
            uniform vec3 uColor5;
            uniform vec3 uColor6;
            uniform float uSpeed;
            uniform float uIntensity;
            uniform sampler2D uTouchTexture;
            uniform float uGrainIntensity;
            uniform vec3 uBaseColor;
            varying vec2 vUv;
            
            float grain(vec2 uv, float time) {
              vec2 grainUv = uv * uResolution * 0.5;
              return fract(sin(dot(grainUv + time, vec2(12.9898, 78.233))) * 43758.5453) * 2.0 - 1.0;
            }
            
            vec3 getGradientColor(vec2 uv, float time) {
              float gradientRadius = 0.5;
              
              vec2 center1 = vec2(0.5 + sin(time * uSpeed * 0.4) * 0.4, 0.5 + cos(time * uSpeed * 0.5) * 0.4);
              vec2 center2 = vec2(0.5 + cos(time * uSpeed * 0.6) * 0.5, 0.5 + sin(time * uSpeed * 0.45) * 0.5);
              vec2 center3 = vec2(0.5 + sin(time * uSpeed * 0.35) * 0.45, 0.5 + cos(time * uSpeed * 0.55) * 0.45);
              vec2 center4 = vec2(0.5 + cos(time * uSpeed * 0.5) * 0.4, 0.5 + sin(time * uSpeed * 0.4) * 0.4);
              vec2 center5 = vec2(0.5 + sin(time * uSpeed * 0.7) * 0.35, 0.5 + cos(time * uSpeed * 0.6) * 0.35);
              vec2 center6 = vec2(0.5 + cos(time * uSpeed * 0.45) * 0.5, 0.5 + sin(time * uSpeed * 0.65) * 0.5);
              
              float dist1 = length(uv - center1);
              float dist2 = length(uv - center2);
              float dist3 = length(uv - center3);
              float dist4 = length(uv - center4);
              float dist5 = length(uv - center5);
              float dist6 = length(uv - center6);
              
              float influence1 = 1.0 - smoothstep(0.0, gradientRadius, dist1);
              float influence2 = 1.0 - smoothstep(0.0, gradientRadius, dist2);
              float influence3 = 1.0 - smoothstep(0.0, gradientRadius, dist3);
              float influence4 = 1.0 - smoothstep(0.0, gradientRadius, dist4);
              float influence5 = 1.0 - smoothstep(0.0, gradientRadius, dist5);
              float influence6 = 1.0 - smoothstep(0.0, gradientRadius, dist6);
              
              vec3 color = uBaseColor;
              color = mix(color, uColor1, influence1 * 0.5 * (0.6 + 0.4 * sin(time * uSpeed)));
              color = mix(color, uColor2, influence2 * 0.45 * (0.6 + 0.4 * cos(time * uSpeed * 1.2)));
              color = mix(color, uColor3, influence3 * 0.5 * (0.6 + 0.4 * sin(time * uSpeed * 0.8)));
              color = mix(color, uColor4, influence4 * 0.4 * (0.6 + 0.4 * cos(time * uSpeed * 1.3)));
              color = mix(color, uColor5, influence5 * 0.45 * (0.6 + 0.4 * sin(time * uSpeed * 1.1)));
              color = mix(color, uColor6, influence6 * 0.4 * (0.6 + 0.4 * cos(time * uSpeed * 0.9)));
              
              return clamp(color, vec3(0.0), vec3(1.0));
            }
            
            void main() {
              vec2 uv = vUv;
              vec4 touchTex = texture2D(uTouchTexture, uv);
              float vx = -(touchTex.r * 2.0 - 1.0);
              float vy = -(touchTex.g * 2.0 - 1.0);
              float intensity = touchTex.b;
              uv.x += vx * 0.1 * intensity;
              uv.y += vy * 0.1 * intensity;
              
              vec3 color = getGradientColor(uv, uTime);
              color += grain(uv, uTime) * uGrainIntensity;
              color = clamp(color, vec3(0.0), vec3(1.0));
              
              gl_FragColor = vec4(color, 1.0);
            }
          `
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.sceneManager.scene.add(this.mesh);
      }
      update(delta) {
        if (this.uniforms.uTime) this.uniforms.uTime.value += delta;
      }
      onResize(width, height) {
        const viewSize = this.sceneManager.getViewSize();
        if (this.mesh) {
          this.mesh.geometry.dispose();
          this.mesh.geometry = new THREE.PlaneGeometry(viewSize.width, viewSize.height, 1, 1);
        }
        if (this.uniforms.uResolution) this.uniforms.uResolution.value.set(width, height);
      }
    }

    // App class
    class App {
      constructor() {
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(this.renderer.domElement);
        this.renderer.domElement.id = "webGLApp";

        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
        this.camera.position.z = 50;
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0xf5f3ff);
        this.clock = new THREE.Clock();

        this.touchTexture = new TouchTexture();
        this.gradientBackground = new GradientBackground(this);
        this.gradientBackground.uniforms.uTouchTexture.value = this.touchTexture.texture;
        this.init();
      }
      init() {
        this.gradientBackground.init();
        this.tick();
        window.addEventListener("resize", () => this.onResize());
        window.addEventListener("mousemove", (ev) => this.onMouseMove(ev));
        window.addEventListener("touchmove", (ev) => this.onTouchMove(ev));
      }
      onTouchMove(ev) {
        const touch = ev.touches[0];
        this.onMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
      }
      onMouseMove(ev) {
        this.mouse = { x: ev.clientX / window.innerWidth, y: 1 - ev.clientY / window.innerHeight };
        this.touchTexture.addTouch(this.mouse);
      }
      getViewSize() {
        const fovInRadians = (this.camera.fov * Math.PI) / 180;
        const height = Math.abs(this.camera.position.z * Math.tan(fovInRadians / 2) * 2);
        return { width: height * this.camera.aspect, height };
      }
      update(delta) {
        this.touchTexture.update();
        this.gradientBackground.update(delta);
      }
      render() {
        const delta = Math.min(this.clock.getDelta(), 0.1);
        this.renderer.render(this.scene, this.camera);
        this.update(delta);
      }
      tick() {
        this.render();
        requestAnimationFrame(() => this.tick());
      }
      onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.gradientBackground.onResize(window.innerWidth, window.innerHeight);
      }
    }

    // Initialize
    const app = new App();

    // Glowing card effect
    const glowingElements = [
        document.getElementById('videoCard'),
        ...document.querySelectorAll('.glowing-card')
    ].filter(Boolean);
    
    const centerOfElement = ($el) => {
      const { width, height } = $el.getBoundingClientRect();
      return [width/2, height/2];
    };
    
    const pointerPositionRelativeToElement = ($el, e) => {
      const { left, top, width, height } = $el.getBoundingClientRect();
      const x = e.clientX - left;
      const y = e.clientY - top;
      const px = Math.min(Math.max((100 / width) * x, 0), 100);
      const py = Math.min(Math.max((100 / height) * y, 0), 100);
      return { pixels: [x,y], percent: [px,py] };
    };
    
    const angleFromPointerEvent = (dx, dy) => {
      if (dx === 0 && dy === 0) return 0;
      let angleRadians = Math.atan2(dy, dx);
      let angleDegrees = angleRadians * (180 / Math.PI) + 90;
      if (angleDegrees < 0) angleDegrees += 360;
      return angleDegrees;
    };
    
    const distanceFromCenter = ($el, x, y) => {
      const [cx,cy] = centerOfElement($el);
      return [x - cx, y - cy];
    };
    
    const closenessToEdge = ($el, x, y) => {
      const [cx,cy] = centerOfElement($el);
      const [dx,dy] = distanceFromCenter($el, x, y);
      let k_x = dx !== 0 ? cx / Math.abs(dx) : Infinity;
      let k_y = dy !== 0 ? cy / Math.abs(dy) : Infinity;
      return Math.min(Math.max(1 / Math.min(k_x, k_y), 0), 1);
    };
    
    const cardUpdate = (e) => {
      const $el = e.currentTarget;
      const position = pointerPositionRelativeToElement($el, e);
      const [px,py] = position.pixels;
      const [dx,dy] = distanceFromCenter($el, px, py);
      const edge = closenessToEdge($el, px, py);
      const angle = angleFromPointerEvent(dx, dy);
      
      $el.style.setProperty('--pointer-Â°', `${angle.toFixed(3)}deg`);
      $el.style.setProperty('--pointer-d', `${(edge * 100).toFixed(3)}`);
      $el.classList.remove('animating');
    };
    
    glowingElements.forEach($el => {
        $el.addEventListener('pointermove', cardUpdate);
    });

    // Loader logic
    const loader = document.getElementById('loader');
    const mainContent = document.getElementById('mainContent');
    const loaderStartTime = Date.now();

    window.addEventListener('load', () => {
        const diff = Date.now() - loaderStartTime;
        const delay = Math.max(0, 3000 - diff);
        
        setTimeout(() => {
            hideLoader();
        }, delay);
    });
    function hideLoader() {
      loader.classList.add('hidden');
      document.body.classList.remove('loading');
      mainContent.classList.add('visible');
      
      // Trigger hero animations
      setTimeout(() => {
          document.querySelectorAll('#hero-cover .reveal-text').forEach((el, index) => {
              setTimeout(() => el.classList.add('visible'), index * 200);
          });
      }, 500);
    }

    // Scroll Animation (Intersection Observer)
    const observerOptions = {
      root: null,
      rootMargin: '0px',
      threshold: 0.1
    };

    const observer = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
        }
      });
    }, observerOptions);

    document.querySelectorAll('.section .reveal-text').forEach(el => {
      observer.observe(el);
    });
  </script>
</body>
</html>